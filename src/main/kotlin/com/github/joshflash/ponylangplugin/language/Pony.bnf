{
  parserClass="com.github.joshflash.ponylangplugin.parser.PonyParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Pony"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.joshflash.ponylangplugin.language.psi"
  psiImplPackage="com.github.joshflash.ponylangplugin.language.psi.impl"

  elementTypeHolderClass="com.github.joshflash.ponylangplugin.language.psi.PonyTypes"
  elementTypeClass="com.github.joshflash.ponylangplugin.language.psi.PonyElementType"
  tokenTypeClass="com.github.joshflash.ponylangplugin.language.psi.PonyTokenType"

  tokens = [
  // keywords
    USE="use"
    TYPE="type"
    INTERFACE="interface"
    TRAIT="trait"
    PRIMITIVE="primitive"
    STRUCT="struct"
    CLASS="class"
    ACTOR="actor"
    OBJECT="object"
    FUN="fun"
    BE="be"
    NEW="new"
    LET="let"
    VAR="var"
    EMBED="embed"
    THIS="this"
    IS="is"
    AS="as"
    ISNT="isnt"
    IF="if"
    NOT="not"
    ELSEIF="elseif"
    THEN="then"
    TRY="try"
    ELSE="else"
    END="end"
    FOR="for"
    IN="in"
    DO="do"
    WHERE="where"
    WHILE="while"
    WITH="with"
    MATCH="match"
    RECOVER="recover"
    CONSUME="consume"
    IFDEF="ifdef"
    IFTYPE="iftype"
    REPEAT="repeat"
    UNTIL="until"
    ISO="iso"
    REF="ref"
    TRN="trn"
    VAL="val"
    BOX="box"
    TAG="tag"
    RETURN="return"
    BREAK="break"
    CONTINUE="continue"
    ERROR="error"
    COMP_INT="compile_intrinsic"
    COMP_ERR="compile_error"
    SOURCELOC="__loc"
    ADDRESSOF="addressof"
    DIGESTOF="digestof"
  // symbols
    EQUALS="="
    ARROW="=>"
    TYPE_ARROW="->"
    COLON=":"
    SEMI=";"
    COMMA=","
    DOT="."
    LP="("
    RP=")"
    LBK="["
    RBK="]"
    LBC="{"
    RBC="}"
    RCVR="@{"
    AT="@"
    QM="?"
    CARET="^"
    BANG="!"
    CHAIN=".>"
    TILDE="~"
    PIPE="|"
    AMP="&"
    ISA="<:"
    HASH="#"
    ELIPSIS="..."
  // operators
    AND="and"
    OR="or"
    XOR="xor"
    ADD="+"
    SUB="-"
    MUL="*"
    DIV="/"
    REM="%"
    MOD="%%"
    SHL="<<"
    SHR=">>"
    EQ="=="
    NEQ="!="
    LT="<"
    GT=">"
    LEQ="<="
    GEQ=">="
    ADD_UNSAFE="+~"
    SUB_UNSAFE="-~"
    MUL_UNSAFE="*~"
    DIV_UNSAFE="/~"
    REM_UNSAFE="%~"
    MOD_UNSAFE="%%~"
    SHL_UNSAFE="<<~"
    SHR_UNSAFE=">>~"
    EQ_UNSAFE="==~"
    NEQ_UNSAFE="!=~"
    LT_UNSAFE="<~"
    GT_UNSAFE=">~"
    LEQ_UNSAFE="<=~"
    GEQ_UNSAFE=">=~"
    ADD_PARTIAL="+?"
    SUB_PARTIAL="-?"
    MUL_PARTIAL="*?"
    DIV_PARTIAL="/?"
    REM_PARTIAL="%?"
    MOD_PARTIAL="%%?"
  // lexemes
    true="true"
    false="false"
    space="regexp:\\s+"
    newline="regexp:\\n[ \\tr]*"
    id="regexp:[a-zA-Z_][a-zA-Z0-9_]*"
    number="regexp:[0-9]+"
    string="regexp:('([^'\\]|\\\\.)*'|\"([^\"\\]|\\\\.)*\")"
    line_comment="regexp://.*"
    block_comment="regexp:/\\*([^*]|\\*+[^*/])*\\*/"
    doc_string="regexp:(?s)\"\"\"(.*?)\"\"\""
    gencap = 'regexp:#(read|send|share|alias|any)'
  ]
}

module ::= [string] use* class_def* ;

use ::= USE [id EQUALS] (string | use_ffi) [IF infix] ;

use_ffi ::= AT (id | string) typeargs LP [params] RP [QM] ;

class_def ::= declaration [idlist] [AT] [cap] id [typeparams] [IS type] [string] members ;

declaration ::= (TYPE | INTERFACE | TRAIT | PRIMITIVE | STRUCT | CLASS | ACTOR) ;

members ::= field* method* ;

field ::= (VAR | LET | EMBED) id COLON type [EQUALS infix] [string] ;

method ::= (FUN | BE | NEW) [idlist] [cap | AT] id [typeparams]
    LP [params] RP [COLON type] [QM] [string] [ARROW rawseq] ;

annotatedrawseq ::= [idlist] (exprseq | jump) ;

rawseq ::= exprseq | jump ;

exprseq ::= assignment [nosemi] ;

nosemi ::= jump | nextexprseq [semiexpr | jump ] ;

nextexprseq ::= nextassignment+ ;

semiexpr ::= SEMI (exprseq | jump) ;

jump ::= (RETURN | BREAK | CONTINUE | ERROR | COMP_INT | COMP_ERR) [rawseq] ;

nextassignment ::= nextinfix [EQUALS assignment] ;

assignment ::= infix [EQUALS assignment] ;

nextinfix ::= nextterm infixop*;

infix ::= term infixop* ;

infixop ::= binop | isop | AS type

isop ::= (IS | ISNT) term ;

safeop ::=
    AND | OR  | XOR | ADD | SUB | MUL
  | DIV | REM | MOD | SHL | SHR | EQ
  | NEQ | LT  | LEQ | GEQ | GT

unsafeop ::=
    ADD_UNSAFE | SUB_UNSAFE | MUL_UNSAFE
  | DIV_UNSAFE | REM_UNSAFE | MOD_UNSAFE
  | SHL_UNSAFE | SHR_UNSAFE | EQ_UNSAFE
  | NEQ_UNSAFE | LT_UNSAFE  | LEQ_UNSAFE
  | GT_UNSAFE  | GEQ_UNSAFE

partialop ::=
    ADD_PARTIAL | SUB_PARTIAL | MUL_PARTIAL
  | DIV_PARTIAL | REM_PARTIAL | MOD_PARTIAL

binop ::=
   ( safeop | unsafeop | partialop ) [QM] term ;

nextterm ::=
    IF [idlist] rawseq THEN rawseq [elseif | (ELSE annotatedrawseq)] END
  | IFDEF [idlist] infix THEN rawseq [elseifdef | (ELSE annotatedrawseq)] END
  | IFTYPE [idlist] iftype [elseiftype | (ELSE annotatedrawseq)] END
  | MATCH [idlist] rawseq caseexpr* [ELSE annotatedrawseq] END
  | WHILE [idlist] rawseq DO rawseq [ELSE annotatedrawseq] END
  | REPEAT [idlist] rawseq UNTIL annotatedrawseq [ELSE annotatedrawseq] END
  | FOR [idlist] idseq IN rawseq DO rawseq [ELSE annotatedrawseq] END
  | WITH [idlist] withelem (COMMA withelem)* DO rawseq END
  | TRY [idlist] rawseq [ELSE annotatedrawseq] [THEN annotatedrawseq] END
  | RECOVER [idlist] [cap] rawseq END
  | CONSUME [cap] term
  | nextpattern
  | HASH postfix ;

term ::=
    IF [idlist] rawseq THEN rawseq [elseif | (ELSE annotatedrawseq)] END
  | IFDEF [idlist] infix THEN rawseq [elseifdef | (ELSE annotatedrawseq)] END
  | IFTYPE [idlist] iftype [elseiftype | (ELSE annotatedrawseq)] END
  | MATCH [idlist] rawseq caseexpr* [ELSE annotatedrawseq] END
  | WHILE [idlist] rawseq DO rawseq [ELSE annotatedrawseq] END
  | REPEAT [idlist] rawseq UNTIL annotatedrawseq [ELSE annotatedrawseq] END
  | FOR [idlist] idseq IN rawseq DO rawseq [ELSE annotatedrawseq] END
  | WITH [idlist] withelem (COMMA withelem)* DO rawseq END
  | TRY [idlist] rawseq [ELSE annotatedrawseq] [THEN annotatedrawseq] END
  | RECOVER [idlist] [cap] rawseq END
  | CONSUME [cap] term
  | pattern
  | HASH postfix ;

withelem ::= idseq EQUALS rawseq ;

caseexpr ::=
    PIPE [idlist] [casepattern] [IF rawseq] [ARROW rawseq] ;

elseiftype ::=
    ELSEIF [idlist] iftype [elseiftype | (ELSE annotatedrawseq)] ;

iftype ::= type ISA type THEN rawseq ;

elseifdef ::=
    ELSEIF [idlist] infix THEN rawseq [elseifdef | (ELSE annotatedrawseq)] ;

elseif ::=
    ELSEIF [idlist] rawseq THEN rawseq [elseif | (ELSE annotatedrawseq)] ;

idseq ::=
    id
  | LP idseq_in_seq (COMMA idseq_in_seq)* RP ;

idseq_in_seq ::=
    id
  | LP idseq_in_seq (COMMA idseq_in_seq)* RP ;

nextpattern ::=
    (VAR | LET | EMBED) id [COLON type]
  | nextparampattern ;

casepattern ::=
    (VAR | LET | EMBED) id [COLON type]
  | caseparampattern ;

pattern ::=
    (VAR | LET | EMBED) id [COLON type]
  | parampattern ;

nextparampattern ::=
    (NOT | ADDRESSOF | newline SUB | newline SUB_UNSAFE | DIGESTOF) parampattern
  | nextpostfix ;

caseparampattern ::=
    (NOT | ADDRESSOF | SUB | SUB_UNSAFE | newline SUB | newline SUB_UNSAFE | DIGESTOF) caseparampattern
  | casepostfix ;

parampattern ::=
    (NOT | ADDRESSOF | SUB | SUB_UNSAFE | newline SUB | newline SUB_UNSAFE | DIGESTOF) parampattern
  | postfix ;

nextpostfix ::= nextatom postfixelem* ;

casepostfix ::= caseatom postfixelem* ;

postfix ::= atom postfixelem* ;

postfixelem ::= dot | tilde | chain | typeargs | call ;

call ::= LP [positional] [named] RP [QM] ;

chain ::= CHAIN id ;

tilde ::= TILDE id ;

dot ::= DOT id ;

nextatom ::=
    id
  | THIS
  | literal
  | newline LP rawseq [tuple] RP
  | newline LBK [AS type COLON] [rawseq] RBK
  | OBJECT [idlist] [cap] [IS type] members END
  | LBC [idlist] [cap] [id] [typeparams] LP [lambdaparams] RP [lambdacaptures]
        [COLON type] [QM] ARROW rawseq RBC [cap]
  | RCVR [idlist] [cap] [id] [typeparams] LP [lambdaparams] RP [lambdacaptures]
        [COLON type] [QM] ARROW rawseq RBC [cap]
  | AT (id | string) [typeargs] LP [positional] [named] RP [QM]
  | SOURCELOC
  | IF [idlist] rawseq THEN rawseq [elseif | (ELSE annotatedrawseq)] END
  | WHILE [idlist] rawseq DO rawseq [ELSE annotatedrawseq] END
  | FOR [idlist] idseq IN rawseq DO rawseq [ELSE annotatedrawseq] END ;

caseatom ::=
    id
  | THIS
  | literal
  | LP rawseq [tuple] RP
  | LBK [AS type COLON] [rawseq] RBK
  | OBJECT [idlist] [cap] [IS type] members END
  | LBC [idlist] [cap] [id] [typeparams] LP [lambdaparams] RP [lambdacaptures]
        [COLON type] [QM] ARROW rawseq RBC [cap]
  | RCVR [idlist] [cap] [id] [typeparams] LP [lambdaparams] RP [lambdacaptures]
        [COLON type] [QM] ARROW rawseq RBC [cap]
  | AT (id | string) [typeargs] LP [positional] [named] RP [QM]
  | SOURCELOC
  | WHILE [idlist] rawseq DO rawseq [ELSE annotatedrawseq] END
  | FOR [idlist] idseq IN rawseq DO rawseq [ELSE annotatedrawseq] END ;

atom ::=
    id
  | THIS
  | literal
  | LP rawseq [tuple] RP
  | LBK [AS type COLON] [rawseq] RBK
  | OBJECT [idlist] [cap] [IS type] members END
  | LBC [idlist] [cap] [id] [typeparams] LP [lambdaparams] RP [lambdacaptures]
        [COLON type] [QM] ARROW rawseq RBC [cap]
  | RCVR [idlist] [cap] [id] [typeparams] LP [lambdaparams] RP [lambdacaptures]
        [COLON type] [QM] ARROW rawseq RBC [cap]
  | AT (id | string) [typeargs] LP [positional] [named] RP [QM]
  | SOURCELOC
  | IF [idlist] rawseq THEN rawseq [elseif | (ELSE annotatedrawseq)] END
  | WHILE [idlist] rawseq DO rawseq [ELSE annotatedrawseq] END
  | FOR [idlist] idseq IN rawseq DO rawseq [ELSE annotatedrawseq] END ;

tuple ::= COMMA rawseq (COMMA rawseq)* ;

lambdacaptures ::= LP (lambdacapture | THIS) (COMMA (lambdacapture | THIS))* RP ;

lambdacapture ::= id [COLON type] [EQUALS infix] ;

lambdaparams ::= lambdaparam (COMMA lambdaparam)* ;

lambdaparam ::= id [COLON type] [EQUALS infix] ;

positional ::= rawseq (COMMA rawseq)* ;

named ::= WHERE namedarg (COMMA namedarg)* ;

namedarg ::= id EQUALS rawseq ;

type ::= atomtype [TYPE_ARROW type] ;

atomtype ::=
    THIS
  | cap
  | LP infixtype [tupletype] RP
  | nominal
  | lambdatype
  | barelambdatype ;

barelambdatype ::=
    RCVR [cap] [id] [typeparams] LP [type (COMMA type)*] RP [COLON type] [QM] RBC [cap | gencap] [CARET | BANG] ;

lambdatype ::=
    LBC [cap] [id] [typeparams] LP [type (COMMA type)*] RP [COLON type] [QM] RBC [cap | gencap] [CARET | BANG] ;

tupletype ::= COMMA infixtype (COMMA infixtype)* ;

infixtype ::= type (uniontype | isecttype)* ;

isecttype ::= AMP type ;

uniontype ::= PIPE type ;

nominal ::= id [DOT id] [typeargs] [cap | gencap] [CARET | BANG] ;

cap ::= ISO | REF | TRN | VAL | BOX | TAG ;

typeargs ::= LBK typearg (COMMA typearg)* RBK ;

typeparams ::= LBK typeparam (COMMA typeparam)* RBK ;

params ::= (param | ELIPSIS) (COMMA (param | ELIPSIS))* ;

typeparam ::= id [COLON type] [EQUALS typearg] ;

typearg ::=
    type
  | literal
  | HASH postfix ;

literal ::=
    true
  | false
  | int
  | float
  | string ;

param ::= id COLON type [EQUALS infix] ;

idlist ::= id (COMMA id)*

